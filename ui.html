<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown to Layers</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --brand-color: #007AFF;
            --brand-color-hover: #005ECC;
            --gray-50: #f9fafb;
            --gray-100: #f3f4f6;
            --gray-200: #e5e7eb;
            --gray-300: #d1d5db;
            --gray-400: #9ca3af;
            --gray-500: #6b7280;
            --gray-600: #4b5563;
            --gray-700: #374151;
            --gray-800: #1f2937;
            --gray-900: #111827;
            --red-500: #ef4444;
            --red-600: #dc2626;
            --green-500: #22c55e;
            --green-600: #16a34a;
            
            /* Theme variables - Default to light theme values */
            --bg-color: var(--gray-50);
            --text-color: var(--gray-800);
            --border-color: var(--gray-300);
            --input-bg: white;
            --header-color: var(--gray-900);
            --label-color: var(--gray-700);
            --preview-bg: white;
            --preview-text: var(--gray-700);
            --preview-code-bg: var(--gray-100);
            --style-mapping-bg: var(--gray-100);
            --spinner-border: var(--gray-200);
            --overlay-bg: rgba(255, 255, 255, 0.8);
        }

        /* Dark mode theme using Figma's injected class */
        html.figma-dark {
            --brand-color: #0A84FF; /* Figma dark mode blue */
            --brand-color-hover: #409CFF;
            --bg-color: #1E1E1E; /* Common dark bg */
            --text-color: #E0E0E0; /* Light text for dark bg */
            --border-color: #444444; /* Darker border */
            --input-bg: #2D2D2D; /* Dark input bg */
            --header-color: #FFFFFF; /* White headers */
            --label-color: #CCCCCC; /* Lighter labels */
            --preview-bg: #2D2D2D;
            --preview-text: #E0E0E0;
            --preview-code-bg: #3D3D3D;
            --style-mapping-bg: #2A2A2A;
            --spinner-border: #444444;
            --overlay-bg: rgba(0, 0, 0, 0.8);
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            padding: 1.5rem; 
            min-height: 100vh;
            box-sizing: border-box;
        }

        /* General UI elements */
        h2.plugin-title {
            font-size: 1.25rem; 
            font-weight: 600;
            margin-bottom: 1.5rem;
            color: var(--header-color);
        }

        label {
            display: block;
            margin-bottom: 0.5rem; 
            font-weight: 500;
            color: var(--label-color);
            font-size: 0.875rem; 
        }

        textarea,
        select {
            width: 100%;
            padding: 1rem; 
            border: 1px solid var(--border-color);
            border-radius: 1rem; 
            background-color: var(--input-bg);
            margin-bottom: 1rem; 
            font-size: 0.8rem;
            color: var(--text-color);
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        html.figma-dark select {
             background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23CCCCCC' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
        }

        html.figma-light select {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%236b7280' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
        }
        
        select {
            appearance: none; 
            background-repeat: no-repeat;
            background-position: right 0.75rem center; 
            padding-right: 2.5rem; 
        }

        textarea:focus,
        select:focus {
            outline: none;
            border-color: var(--brand-color);
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.25); 
        }
        
        textarea#markdown-input {
            min-height: 150px;
            resize: vertical;
        }

        button {
            padding: 0.625rem 1.25rem; 
            border-radius: 32px; 
            font-weight: 500; 
            font-size: 0.875rem; 
            cursor: pointer;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }

        button.primary {
            background-color: var(--brand-color);
            color: white; /* Text color for primary buttons is usually white for contrast */
            border: none;
        }
        html.figma-dark button.primary {
            color: #FFFFFF; /* Ensure white text on dark primary */
        }
        html.figma-light button.primary {
            color: white;
        }
        button.primary:hover {
            background-color: var(--brand-color-hover);
        }

        button.primary:disabled {
            background-color: var(--gray-400);
            cursor: not-allowed;
            opacity: 0.7;
        }

        button.secondary {
            background-color:var(--gray-200); /* Light theme default */
            color: var(--gray-900);  /* Light theme default */
            border: 1px solid var(--gray-300); /* Light theme default */
        }
        
        html.figma-dark button.secondary {
            background-color: #3D3D3D;
            color: #E0E0E0;
            border: 1px solid #555555; /* Slightly distinct border for dark mode secondary */
        }
        
        button.secondary:hover {
            background-color: var(--gray-300); /* Light theme default */
            color: var(--gray-900); /* Light theme default */
        }
        
        html.figma-dark button.secondary:hover {
            background-color: #4D4D4D;
            color: #FFFFFF;
        }

        /* Preview Area */
        #preview {
            border: 1px solid var(--border-color);
            padding: 1rem; 
            min-height: 120px; 
            background-color: var(--preview-bg);
            border-radius: 16px;
            overflow-y: auto;
            max-height: 250px; 
            font-size: 0.875rem;
            line-height: 1.6;
            margin-bottom: 1.5rem;
        }
        #preview h1 { font-size: 1.5rem; font-weight: 600; margin-bottom: 0.75rem; color: var(--header-color); }
        #preview h2 { font-size: 1.25rem; font-weight: 600; margin-bottom: 0.625rem; color: var(--header-color); }
        #preview h3 { font-size: 1.125rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--label-color); }
        #preview p { margin-bottom: 0.75rem; color: var(--preview-text); }
        #preview ul, #preview ol { margin-left: 1.25rem; margin-bottom: 0.75rem; color: var(--preview-text); }
        #preview li { margin-bottom: 0.375rem; }
        #preview a { color: var(--brand-color); text-decoration: none; }
        #preview a:hover { text-decoration: underline; }
        #preview code { background-color: var(--preview-code-bg); padding: 0.125rem 0.25rem; border-radius: 0.25rem; font-size: 0.8em;}
        #preview pre { background-color: var(--preview-code-bg); padding: 0.75rem; border-radius: 0.375rem; overflow-x: auto; margin-bottom: 0.75rem;}


        /* Style Mapping Section */
        #style-mapping-container {
            margin-top: 1rem;
            padding: 1rem; /* 12px */
            background-color: var(--style-mapping-bg); 
            border-radius: 1rem; 
            margin-bottom: 1.5rem;
        }
        #style-mapping-container h3 {
            font-size: 1.25rem; 
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--header-color);
        }
        #style-mapping-container p.description {
            font-size: 0.875rem; 
            color: var(--label-color);
            margin-bottom: 1rem;
        }
        #style-mapping-options .mapping-item { 
            margin-bottom: 1rem; 
        }

        /* Spinner */
        #loading-spinner {
            border: 4px solid var(--spinner-border); 
            border-top: 4px solid var(--brand-color); 
            border-radius: 50%;
            width: 36px; 
            height: 36px;
            animation: spin 0.8s linear infinite;
            margin: 0 auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #loading-container, #error-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--overlay-bg); 
            z-index: 999;
        }
        #error-container {
            color: var(--red-600);
        }
        #loading-container .message, #error-container .message {
             margin-top: 1rem;
             font-size: 0.875rem;
             color: var(--text-color);
             font-weight: 500;
        }
         #error-container .icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }


        /* Clipboard UI */
        #clipboard-status {
            margin-bottom: 1rem;
            font-size: 0.875rem;
            color: var(--text-color);
            font-weight: 500;
        }
        #manual-copy-area {
            width: 100%;
            height: 120px;
            margin-bottom: 1rem;
            font-family: monospace; 
            font-size: 0.875rem;
            background-color: var(--input-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
        }
        
        /* Utility to hide elements */
        .hidden {
            display: none !important;
        }

    </style>
</head>
<body>
    <!-- Spinner and loading message -->
    <div id="loading-container" class="hidden">
        <div id="loading-spinner"></div>
        <div class="message">Connecting to plugin service...</div>
    </div>
    <!-- Error message -->
    <div id="error-container" class="hidden">
        <div class="icon">⚠️</div>
        <div class="message">Plugin service is currently unavailable.<br>Please check your internet connection or try again later.</div>
    </div>

    <!-- Main Content (hidden initially) -->
    <div id="main-content" class="hidden pb-12">
        <h2 class="plugin-title">Convert Markdown to Layers</h2>
        
        <div class="mb-6"> 
            <label for="markdown-input">Enter Markdown:</label>
            <textarea id="markdown-input" class="p-3 text-[13px]" placeholder="# Heading 1&#10;## Heading 2&#10;This is a paragraph with **bold** and *italic* text.&#10;- List item 1&#10;- List item 2&#10;[Example Link](https://example.com)"></textarea>
        </div>
        
        <div class="mb-6"> 
            <label for="preview">Preview:</label>
            <div id="preview" class="p-4"></div>
        </div>
        
        <div id="style-mapping-container">
            <h3>Map to Figma Text Styles</h3>
            <p class="description">Select which local text styles should be applied to each Markdown element. If no style is selected, default text settings will be used.</p>
            <div id="style-mapping-options">
                <!-- Mapping options will be populated here by JS -->
            </div>
        </div>
        
        <div class="fixed bottom-0 left-0 right-0 bg-[var(--bg-color)] flex space-x-[12px] p-4 shadow-md z-10 border-t border-[var(--border-color)]">
            <button id="cancel-button" class="secondary py-2 pl-8 px-8">Cancel</button>
            <button id="convert-button" class="primary flex-1 py-2">Convert from Input</button>
        </div>
    </div>

    <!-- Special UI for clipboard operations -->
    <div id="clipboard-ui" class="hidden">
        <h2 class="plugin-title mb-4">Copy Markdown to Clipboard</h2>
        <div id="clipboard-status">Please copy the text manually below.</div>
        <textarea id="manual-copy-area" class="p-3 text-[12px]" readonly></textarea>
        <button id="manual-copy-button" class="primary w-full py-2 mt-3">Copy to Clipboard</button>
    </div>

    <script>
        // DOM Elements
        const markdownInput = document.getElementById('markdown-input');
        const preview = document.getElementById('preview');
        const convertButton = document.getElementById('convert-button');
        const cancelButton = document.getElementById('cancel-button');
        const styleMappingOptions = document.getElementById('style-mapping-options');
        const loadingContainer = document.getElementById('loading-container');
        const mainContent = document.getElementById('main-content');
        const errorContainer = document.getElementById('error-container');
        const clipboardUI = document.getElementById('clipboard-ui');
        const clipboardStatus = document.getElementById('clipboard-status'); 
        const manualCopyArea = document.getElementById('manual-copy-area');
        const manualCopyButton = document.getElementById('manual-copy-button');
        
        // Set convert button to disabled by default
        convertButton.disabled = true;

        // Function to check if markdown input has content
        function checkMarkdownInput() {
            convertButton.disabled = !markdownInput.value.trim();
        }
        
        // Initial state setup
        function showLoading() {
            if (loadingContainer) loadingContainer.classList.remove('hidden');
            if (mainContent) mainContent.classList.add('hidden');
            if (errorContainer) errorContainer.classList.add('hidden');
            if (clipboardUI) clipboardUI.classList.add('hidden');
        }

        function showErrorUI(message = "Plugin service is currently unavailable.<br>Please check your internet connection or try again later.") {
            if (loadingContainer) loadingContainer.classList.add('hidden');
            if (mainContent) mainContent.classList.add('hidden');
            if (errorContainer) {
                errorContainer.classList.remove('hidden');
                const messageDiv = errorContainer.querySelector('.message');
                if (messageDiv) {
                    messageDiv.innerHTML = message;
                } else {
                    console.error("Error container's message div not found!");
                }
            }
            if (clipboardUI) clipboardUI.classList.add('hidden');
        }

        function showMainUI() {
            if (loadingContainer) loadingContainer.classList.add('hidden');
            if (mainContent) mainContent.classList.remove('hidden');
            if (errorContainer) errorContainer.classList.add('hidden');
            if (clipboardUI) clipboardUI.classList.add('hidden');
        }
        
        function showClipboardUI() {
            if (loadingContainer) loadingContainer.classList.add('hidden');
            if (mainContent) mainContent.classList.add('hidden');
            if (errorContainer) errorContainer.classList.add('hidden');
            if (clipboardUI) clipboardUI.classList.remove('hidden');
        }

        let availableStyles = [];
        const markdownElements = [
            { key: 'h1', label: 'Heading 1 (#)', selector: 'h1' },
            { key: 'h2', label: 'Heading 2 (##)', selector: 'h2' },
            { key: 'h3', label: 'Heading 3 (###)', selector: 'h3' },
            { key: 'p', label: 'Paragraph', selector: 'p' },
            { key: 'li', label: 'List Item (-, *)', selector: 'li' },
            { key: 'a', label: 'Link', selector: 'a' },
        ];

        async function handleClipboardAccess() {
            try {
                const readPerm = await navigator.permissions.query({ name: 'clipboard-read' });
                if ((readPerm.state === 'granted' || readPerm.state === 'prompt')) { 
                    return true;
                }
                return false;
            } catch (e) {
                console.warn("Clipboard permissions API not fully available or errored:", e);
                return true; 
            }
        }

        async function getClipboardText() { 
            try {
                if (!(navigator.clipboard && navigator.clipboard.readText)) {
                     throw new Error("Browser does not support clipboard read API.");
                }
                if (await handleClipboardAccess()) {
                    const text = await navigator.clipboard.readText();
                    console.log("Read from clipboard, length:", text.length);
                    return text;
                }
                throw new Error("Clipboard permission denied for reading.");
            } catch (e) {
                console.error("Error reading clipboard:", e);
                showErrorUI(`Clipboard read error: ${e.message || 'Permission denied or API not supported.'}`);
                throw e; 
            }
        }
        
        function updatePreview() {
            if (typeof marked === 'undefined') {
                preview.innerHTML = '<p style="color: var(--red-500);">Error: Preview library (marked.js) not loaded.</p>';
                return;
            }
            try {
                const markdownText = markdownInput.value;
                const sanitizedHtml = marked.parse(markdownText);
                preview.innerHTML = sanitizedHtml;
            } catch (e) {
                console.error("Error updating preview:", e);
                preview.innerHTML = '<p style="color: var(--red-500);">Error rendering preview.</p>';
            }
        }
        
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        const debouncedUpdatePreview = debounce(updatePreview, 250); 
        
        function populateStyleMappings(styles) {
            availableStyles = styles;
            styleMappingOptions.innerHTML = ''; 
            if (!styles || styles.length === 0) {
                styleMappingOptions.innerHTML = '<p class="text-sm text-gray-500">No local text styles found in this document.</p>';
                return;
            }
            markdownElements.forEach(element => {
                const container = document.createElement('div');
                container.className = 'mapping-item items-center'; 

                const label = document.createElement('label');
                label.htmlFor = `map-${element.key}`;
                label.textContent = element.label;
                label.classList.add('mb-2');

                const select = document.createElement('select');
                select.id = `map-${element.key}`;
                select.classList.add('w-full');
                select.classList.add('py-2', 'pl-4');

                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = 'Default (No Style)';
                select.appendChild(defaultOption);

                styles.forEach(style => {
                    const option = document.createElement('option');
                    option.value = style.id;
                    option.textContent = style.name;
                    select.appendChild(option);
                });
                
                container.appendChild(label);
                container.appendChild(select);
                styleMappingOptions.appendChild(container);
            });
        }
        
        window.onmessage = async (event) => {
            if (event.data.pluginMessage) {
                const { type, data, error } = event.data.pluginMessage;
                console.log("Message from Figma:", type, data, error);

                switch (type) {
                    case 'stylesLoaded':
                        populateStyleMappings(data);
                        break;
                    case 'conversionError':
                        alert(`Error during conversion: ${data.message}`); 
                        console.error('Conversion Error from Figma:', data.message);
                        break;
                    case 'selectionError':
                        alert(`Selection error: ${data.message}`);
                        console.error('Selection Error from Figma:', data.message);
                        break;
                    case 'stylesError':
                        styleMappingOptions.innerHTML = `<p class="text-sm text-red-500">Error loading styles: ${data.message}</p>`;
                        break;
                    case 'getClipboardContent': 
                        try {
                            const clipboardText = await getClipboardText(); 
                            parent.postMessage({ pluginMessage: { type: 'clipboardContent', data: clipboardText } }, '*');
                        } catch (e) {
                            parent.postMessage({ pluginMessage: { type: 'clipboardError', error: e.message || 'Could not read clipboard' } }, '*');
                        }
                        break;
                    case 'showMarkdownForManualCopy': 
                        showClipboardUI();
                        manualCopyArea.value = data;
                        setTimeout(() => { 
                            manualCopyArea.focus();
                            manualCopyArea.select();
                        }, 50); 
                        break;
                    default:
                        console.log("Received unknown message type from Figma:", type);
                }
            }
        };

        convertButton.onclick = () => {
            try {
                const markdown = markdownInput.value;
                if (!markdown.trim()) {
                    alert("Markdown input is empty. Please enter some Markdown to convert.");
                    return;
                }
                const mappings = {};
                markdownElements.forEach(element => {
                    const select = document.getElementById(`map-${element.key}`);
                    if (select && select.value) {
                        mappings[element.key] = select.value;
                    }
                });
                parent.postMessage({ pluginMessage: { type: 'convertMarkdown', data: { markdown, mappings } } }, '*');
            } catch (e) {
                console.error("UI error on convert:", e);
                alert("An unexpected error occurred in the UI. Check the console.");
            }
        };

        cancelButton.onclick = () => {
            parent.postMessage({ pluginMessage: { type: 'cancel' } }, '*');
        };

        manualCopyButton.onclick = () => {
            manualCopyArea.select();
            manualCopyArea.setSelectionRange(0, manualCopyArea.value.length); 
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    manualCopyButton.textContent = 'Copied!';
                    manualCopyButton.disabled = true;
                    setTimeout(() => {
                        parent.postMessage({ pluginMessage: { type: 'clipboardSet' } }, '*'); 
                    }, 1500);
                } else {
                     throw new Error("document.execCommand('copy') returned false.");
                }
            } catch (e) {
                console.error("Manual copy failed:", e);
                clipboardStatus.textContent = "Copy failed. Please press Ctrl+C or Cmd+C.";
            }
        };
        
        function initializePluginUI() {
            if (typeof marked === 'undefined') {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/marked/marked.min.js';
                script.onload = () => {
                    console.log("marked.js loaded dynamically.");
                    mainUISetup();
                };
                script.onerror = () => {
                    console.error("Failed to load marked.js from CDN.");
                    showErrorUI("Could not load preview library. Please check your internet connection.");
                };
                document.body.appendChild(script);
            } else {
                mainUISetup();
            }
        }

        function mainUISetup() {
            showMainUI(); 
            markdownInput.addEventListener('input', function() {
                debouncedUpdatePreview();
                checkMarkdownInput();
            });
            updatePreview();
            parent.postMessage({ pluginMessage: { type: 'getStyles' } }, '*'); 
        }
        
        if (window.innerWidth > 10 && window.innerHeight > 10) { 
            showLoading(); 
            initializePluginUI(); 
        } else {
             console.log("Running in potentially headless mode or very small UI. Waiting for plugin commands...");
             document.body.style.background = 'transparent'; 
             if (loadingContainer) loadingContainer.classList.add('hidden'); 
        }

    </script>
</body>
</html>
